theory WPA3_wpa3_reuse_once_3_5 begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: add/2, fst/1, get_add_blk1/2[destructor],
           get_add_blk2/2[destructor], h/1, hkck/3, hmk/3, hpe/3, hpsk/1, hptk/6,
           mac/2, pair/2, snd/1, staticpsk/0[private,destructor], true/0, verif/3
equations:
    fst(<x.1, x.2>) = x.1,
    get_add_blk1(add(a, b), b) = a,
    get_add_blk2(add(a, b), a) = b,
    snd(<x.1, x.2>) = x.2,
    verif(mac(m, k), m, k) = true









rule (modulo E) MisGenerateRandoms:
   [ Fr( ~ma3 ), Fr( ~SNonce5 ) ]
  --[ MisgenerateOnlyOnce( ) ]->
   [ Random3( ~ma3 ), Random5( ~ma3 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) GenRandom5:
   [ Fr( ~SNonce5 ) ] --> [ Random5( ~SNonce5 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) GenRandom4:
   [ Fr( ~ANonce4 ) ] --> [ Random4( ~ANonce4 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) GenRandom3:
   [ Fr( ~ma3 ) ] --> [ Random3( ~ma3 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) GenRandom2:
   [ Fr( ~ska2 ) ] --> [ Random2( ~ska2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) GenRandom1:
   [ Fr( ~mc1 ) ] --> [ Random1( ~mc1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) GenRandom0:
   [ Fr( ~skc0 ) ] --> [ Random0( ~skc0 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) CreateSession:
   [ ]
  --[ Create( $AP, $Client, staticpsk, hpe($AP, $Client, staticpsk) ) ]->
   [
   APReady( $AP, $Client, staticpsk, hpe($AP, $Client, staticpsk) ),
   ClientReady( $AP, $Client, staticpsk, hpe($AP, $Client, staticpsk) ),
   !PskUsed( staticpsk ), !Ltk( $AP, staticpsk ), !Ltk( $Client, staticpsk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) RevLtk:
   [ !Ltk( A, k ) ] --[ RevLtk( ) ]-> [ Out( k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ClientCreateSession:
   [ ClientReady( $AP, $Client, psk, pe ), Random0( ~skc ), Random1( ~mc ) ]
  --[
  ClientStarted1( $AP, $Client, psk, pe, ~skc, inv(pe^~mc), add(~mc, ~skc)
  )
  ]->
   [
   Out( <inv(pe^~mc), add(~mc, ~skc)> ),
   ClientStep1( $AP, $Client, psk, pe, ~skc, inv(pe^~mc), add(~mc, ~skc) )
   ]

  /*
  rule (modulo AC) ClientCreateSession:
     [ ClientReady( $AP, $Client, psk, pe ), Random0( ~skc ), Random1( ~mc ) ]
    --[ ClientStarted1( $AP, $Client, psk, pe, ~skc, z, add(~mc, ~skc) ) ]->
     [
     Out( <z, add(~mc, ~skc)> ),
     ClientStep1( $AP, $Client, psk, pe, ~skc, z, add(~mc, ~skc) )
     ]
    variants (modulo AC)
     1. ~mc   = ~mc.8
        pe    = pe.8
        z     = inv(pe.8^~mc.8)
    
     2. ~mc   = ~x.8
        pe    = x.10^inv(~x.8)
        z     = inv(x.10)
    
     3. ~mc   = ~x.8
        pe    = x.10^inv((~x.8*x.11))
        z     = inv(x.10^inv(x.11))
    
     4. ~mc   = ~x.8
        pe    = x.10^(x.11*inv(~x.8))
        z     = inv(x.10^x.11)
    
     5. ~mc   = ~x.8
        pe    = x.10^(x.11*inv((~x.8*x.12)))
        z     = inv(x.10^(x.11*inv(x.12)))
    
     6. ~mc   = ~x.8
        pe    = inv(x.10)^inv(~x.8)
        z     = x.10
    
     7. ~mc   = ~x.8
        pe    = one^inv(~x.8)
        z     = one
    
     8. ~mc   = ~x.8
        pe    = (x.10*inv(x.11))^inv(~x.8)
        z     = (x.11*inv(x.10))
    
     9. ~mc   = ~mc.10
        pe    = x.8^x.9
        z     = inv(x.8^(x.9*~mc.10))
    
    10. pe    = DH_neutral
        z     = inv(DH_neutral)
  */

rule (modulo E) APCreateSession:
   [
   APReady( $AP, $Client, psk, pe ), Random2( ~ska ), Random3( ~ma ),
   In( <eltc, scalarc> )
   ]
  --[
  LblAPStarted( $AP, $Client, psk, pe, ~ska, inv(pe^~ma), eltc,
                add(~ma, ~ska), scalarc
  )
  ]->
   [
   Out( <inv(pe^~ma), add(~ma, ~ska)> ),
   APStep1( $AP, $Client, psk, pe, ~ska, inv(pe^~ma), eltc, add(~ma, ~ska),
            scalarc
   ),
   APProduceKey( $AP, $Client, psk, pe, ~ska, eltc, scalarc )
   ]

  /*
  rule (modulo AC) APCreateSession:
     [
     APReady( $AP, $Client, psk, pe ), Random2( ~ska ), Random3( ~ma ),
     In( <eltc, scalarc> )
     ]
    --[
    LblAPStarted( $AP, $Client, psk, pe, ~ska, z, eltc, add(~ma, ~ska),
                  scalarc
    )
    ]->
     [
     Out( <z, add(~ma, ~ska)> ),
     APStep1( $AP, $Client, psk, pe, ~ska, z, eltc, add(~ma, ~ska), scalarc ),
     APProduceKey( $AP, $Client, psk, pe, ~ska, eltc, scalarc )
     ]
    variants (modulo AC)
     1. ~ma   = ~ma.10
        pe    = pe.10
        z     = inv(pe.10^~ma.10)
    
     2. ~ma   = ~x.10
        pe    = x.13^inv(~x.10)
        z     = inv(x.13)
    
     3. ~ma   = ~x.10
        pe    = x.13^inv((~x.10*x.14))
        z     = inv(x.13^inv(x.14))
    
     4. ~ma   = ~x.10
        pe    = x.13^(x.14*inv(~x.10))
        z     = inv(x.13^x.14)
    
     5. ~ma   = ~x.10
        pe    = x.13^(x.14*inv((~x.10*x.15)))
        z     = inv(x.13^(x.14*inv(x.15)))
    
     6. ~ma   = ~x.10
        pe    = inv(x.13)^inv(~x.10)
        z     = x.13
    
     7. ~ma   = ~x.10
        pe    = one^inv(~x.10)
        z     = one
    
     8. ~ma   = ~x.10
        pe    = (x.13*inv(x.14))^inv(~x.10)
        z     = (x.14*inv(x.13))
    
     9. ~ma   = ~ma.12
        pe    = x.10^x.11
        z     = inv(x.10^(x.11*~ma.12))
    
    10. pe    = DH_neutral
        z     = inv(DH_neutral)
  */

rule (modulo E) ClientRecvPkey:
   [
   ClientStep1( $AP, $Client, psk, pe, ~skc, eltc, scalarc ),
   In( <elta, scalara> )
   ]
  -->
   [
   ClientProduceKey( $AP, $Client, psk, pe, ~skc, elta, scalara ),
   ClientReadyCommit( $AP, $Client, psk, pe, ~skc, elta, eltc, scalara,
                      scalarc
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) AttDerivePubKey:
   [
   !PskUsed( psk ), In( hpe($AP, $Client, psk) ),
   In( inv(hpe($AP, $Client, psk)^~m) ), In( add(~m, ~s) )
   ]
  -->
   [ Out( hpe($AP, $Client, psk)^~s ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) APDeriveSS:
   [
   APProduceKey( $AP, $Client, psk, pe, ~ska, inv(pe^~mc), add(~mc, ~skc) )
   ]
  -->
   [ APGetKey( $AP, $Client, psk, ~ska, pe^~ska^~skc ) ]

  /*
  rule (modulo AC) APDeriveSS:
     [ APProduceKey( $AP, $Client, psk, pe, ~ska, z, add(~mc, ~skc) ) ]
    -->
     [ APGetKey( $AP, $Client, psk, ~ska, z.1 ) ]
    variants (modulo AC)
     1. ~mc   = ~mc.10
        ~ska  = ~ska.10
        ~skc  = ~skc.10
        pe    = pe.10
        z     = inv(pe.10^~mc.10)
        z.1   = pe.10^(~ska.10*~skc.10)
    
     2. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.11
        pe    = one^inv(~x.10)
        z     = one
        z.1   = one^~skc.11
    
     3. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^inv((~x.10*~x.11))
        z     = inv(x.12^inv(~x.11))
        z.1   = x.12
    
     4. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^inv((~x.10*~x.11*x.13))
        z     = inv(x.12^inv((~x.11*x.13)))
        z.1   = x.12^inv(x.13)
    
     5. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^(x.13*inv((~x.10*~x.11)))
        z     = inv(x.12^(x.13*inv(~x.11)))
        z.1   = x.12^x.13
    
     6. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^(x.13*inv((~x.10*~x.11*x.14)))
        z     = inv(x.12^(x.13*inv((~x.11*x.14))))
        z.1   = x.12^(x.13*inv(x.14))
    
     7. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.13
        pe    = x.12^inv(~x.10)
        z     = inv(x.12)
        z.1   = x.12^~skc.13
    
     8. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.13
        pe    = inv(x.12)^inv(~x.10)
        z     = x.12
        z.1   = inv(x.12)^~skc.13
    
     9. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = x.12^inv((~x.10*x.13))
        z     = inv(x.12^inv(x.13))
        z.1   = x.12^(~skc.14*inv(x.13))
    
    10. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = x.12^(x.13*inv(~x.10))
        z     = inv(x.12^x.13)
        z.1   = x.12^(x.13*~skc.14)
    
    11. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = (x.12*inv(x.13))^inv(~x.10)
        z     = (x.13*inv(x.12))
        z.1   = (x.12*inv(x.13))^~skc.14
    
    12. ~mc   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.15
        pe    = x.12^(x.13*inv((~x.10*x.14)))
        z     = inv(x.12^(x.13*inv(x.14)))
        z.1   = x.12^(x.13*~skc.15*inv(x.14))
    
    13. ~mc   = ~x.10
        ~ska  = ~ska.11
        ~skc  = ~x.10
        pe    = one^inv(~x.10)
        z     = one
        z.1   = one^~ska.11
    
    14. ~mc   = ~x.10
        ~ska  = ~ska.11
        ~skc  = ~skc.11
        pe    = one^inv(~x.10)
        z     = one
        z.1   = one^(~ska.11*~skc.11*inv(~x.10))
    
    15. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.10
        pe    = x.12^inv((~x.10*~x.11))
        z     = inv(x.12^inv(~x.11))
        z.1   = x.12
    
    16. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.10
        pe    = x.12^inv((~x.10*~x.11*x.13))
        z     = inv(x.12^inv((~x.11*x.13)))
        z.1   = x.12^inv(x.13)
    
    17. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.10
        pe    = x.12^(x.13*inv((~x.10*~x.11)))
        z     = inv(x.12^(x.13*inv(~x.11)))
        z.1   = x.12^x.13
    
    18. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.10
        pe    = x.12^(x.13*inv((~x.10*~x.11*x.14)))
        z     = inv(x.12^(x.13*inv((~x.11*x.14))))
        z.1   = x.12^(x.13*inv(x.14))
    
    19. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.12
        pe    = x.13^inv((~x.10*~x.11*~x.12))
        z     = inv(x.13^inv((~x.11*~x.12)))
        z.1   = x.13^inv(~x.10)
    
    20. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.12
        pe    = x.13^inv((~x.10*~x.11*~x.12*x.14))
        z     = inv(x.13^inv((~x.11*~x.12*x.14)))
        z.1   = x.13^inv((~x.10*x.14))
    
    21. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.12
        pe    = x.13^(x.14*inv((~x.10*~x.11*~x.12)))
        z     = inv(x.13^(x.14*inv((~x.11*~x.12))))
        z.1   = x.13^(x.14*inv(~x.10))
    
    22. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.12
        pe    = x.13^(x.14*inv((~x.10*~x.11*~x.12*x.15)))
        z     = inv(x.13^(x.14*inv((~x.11*~x.12*x.15))))
        z.1   = x.13^(x.14*inv((~x.10*x.15)))
    
    23. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~skc.14
        pe    = x.13^inv((~x.10*~x.11))
        z     = inv(x.13^inv(~x.11))
        z.1   = x.13^(~skc.14*inv(~x.10))
    
    24. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~skc.15
        pe    = x.13^inv((~x.10*~x.11*x.14))
        z     = inv(x.13^inv((~x.11*x.14)))
        z.1   = x.13^(~skc.15*inv((~x.10*x.14)))
    
    25. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~skc.15
        pe    = x.13^(x.14*inv((~x.10*~x.11)))
        z     = inv(x.13^(x.14*inv(~x.11)))
        z.1   = x.13^(x.14*~skc.15*inv(~x.10))
    
    26. ~mc   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~skc.16
        pe    = x.13^(x.14*inv((~x.10*~x.11*x.15)))
        z     = inv(x.13^(x.14*inv((~x.11*x.15))))
        z.1   = x.13^(x.14*~skc.16*inv((~x.10*x.15)))
    
    27. ~mc   = ~x.10
        ~ska  = ~ska.13
        ~skc  = ~x.10
        pe    = x.12^inv(~x.10)
        z     = inv(x.12)
        z.1   = x.12^~ska.13
    
    28. ~mc   = ~x.10
        ~ska  = ~ska.13
        ~skc  = ~x.10
        pe    = inv(x.12)^inv(~x.10)
        z     = x.12
        z.1   = inv(x.12)^~ska.13
    
    29. ~mc   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~x.10
        pe    = x.12^inv((~x.10*x.13))
        z     = inv(x.12^inv(x.13))
        z.1   = x.12^(~ska.14*inv(x.13))
    
    30. ~mc   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~x.10
        pe    = x.12^(x.13*inv(~x.10))
        z     = inv(x.12^x.13)
        z.1   = x.12^(x.13*~ska.14)
    
    31. ~mc   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~x.10
        pe    = (x.12*inv(x.13))^inv(~x.10)
        z     = (x.13*inv(x.12))
        z.1   = (x.12*inv(x.13))^~ska.14
    
    32. ~mc   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~x.12
        pe    = x.13^inv((~x.10*~x.12))
        z     = inv(x.13^inv(~x.12))
        z.1   = x.13^(~ska.14*inv(~x.10))
    
    33. ~mc   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~skc.14
        pe    = x.13^inv(~x.10)
        z     = inv(x.13)
        z.1   = x.13^(~ska.14*~skc.14*inv(~x.10))
    
    34. ~mc   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~skc.14
        pe    = inv(x.13)^inv(~x.10)
        z     = x.13
        z.1   = inv(x.13)^(~ska.14*~skc.14*inv(~x.10))
    
    35. ~mc   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~x.10
        pe    = x.12^(x.13*inv((~x.10*x.14)))
        z     = inv(x.12^(x.13*inv(x.14)))
        z.1   = x.12^(x.13*~ska.15*inv(x.14))
    
    36. ~mc   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~x.12
        pe    = x.13^inv((~x.10*~x.12*x.14))
        z     = inv(x.13^inv((~x.12*x.14)))
        z.1   = x.13^(~ska.15*inv((~x.10*x.14)))
    
    37. ~mc   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~x.12
        pe    = x.13^(x.14*inv((~x.10*~x.12)))
        z     = inv(x.13^(x.14*inv(~x.12)))
        z.1   = x.13^(x.14*~ska.15*inv(~x.10))
    
    38. ~mc   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~skc.15
        pe    = x.13^inv((~x.10*x.14))
        z     = inv(x.13^inv(x.14))
        z.1   = x.13^(~ska.15*~skc.15*inv((~x.10*x.14)))
    
    39. ~mc   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~skc.15
        pe    = x.13^(x.14*inv(~x.10))
        z     = inv(x.13^x.14)
        z.1   = x.13^(x.14*~ska.15*~skc.15*inv(~x.10))
    
    40. ~mc   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~skc.15
        pe    = (x.13*inv(x.14))^inv(~x.10)
        z     = (x.14*inv(x.13))
        z.1   = (x.13*inv(x.14))^(~ska.15*~skc.15*inv(~x.10))
    
    41. ~mc   = ~x.10
        ~ska  = ~ska.16
        ~skc  = ~x.12
        pe    = x.13^(x.14*inv((~x.10*~x.12*x.15)))
        z     = inv(x.13^(x.14*inv((~x.12*x.15))))
        z.1   = x.13^(x.14*~ska.16*inv((~x.10*x.15)))
    
    42. ~mc   = ~x.10
        ~ska  = ~ska.16
        ~skc  = ~skc.16
        pe    = x.13^(x.14*inv((~x.10*x.15)))
        z     = inv(x.13^(x.14*inv(x.15)))
        z.1   = x.13^(x.14*~ska.16*~skc.16*inv((~x.10*x.15)))
    
    43. ~mc   = ~mc.12
        ~ska  = ~ska.12
        ~skc  = ~x.10
        pe    = x.11^inv(~x.10)
        z     = inv(x.11^(~mc.12*inv(~x.10)))
        z.1   = x.11^~ska.12
    
    44. ~mc   = ~mc.12
        ~ska  = ~ska.12
        ~skc  = ~skc.12
        pe    = x.10^x.11
        z     = inv(x.10^(x.11*~mc.12))
        z.1   = x.10^(x.11*~ska.12*~skc.12)
    
    45. ~mc   = ~mc.13
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^inv((~x.10*~x.11))
        z     = inv(x.12^(~mc.13*inv((~x.10*~x.11))))
        z.1   = x.12
    
    46. ~mc   = ~mc.13
        ~ska  = ~x.10
        ~skc  = ~skc.13
        pe    = x.12^inv(~x.10)
        z     = inv(x.12^(~mc.13*inv(~x.10)))
        z.1   = x.12^~skc.13
    
    47. ~mc   = ~mc.13
        ~ska  = ~ska.13
        ~skc  = ~x.10
        pe    = x.11^inv((~x.10*x.12))
        z     = inv(x.11^(~mc.13*inv((~x.10*x.12))))
        z.1   = x.11^(~ska.13*inv(x.12))
    
    48. ~mc   = ~mc.13
        ~ska  = ~ska.13
        ~skc  = ~x.10
        pe    = x.11^(x.12*inv(~x.10))
        z     = inv(x.11^(x.12*~mc.13*inv(~x.10)))
        z.1   = x.11^(x.12*~ska.13)
    
    49. ~mc   = ~mc.14
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^inv((~x.10*~x.11*x.13))
        z     = inv(x.12^(~mc.14*inv((~x.10*~x.11*x.13))))
        z.1   = x.12^inv(x.13)
    
    50. ~mc   = ~mc.14
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^(x.13*inv((~x.10*~x.11)))
        z     = inv(x.12^(x.13*~mc.14*inv((~x.10*~x.11))))
        z.1   = x.12^x.13
    
    51. ~mc   = ~mc.14
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = x.12^inv((~x.10*x.13))
        z     = inv(x.12^(~mc.14*inv((~x.10*x.13))))
        z.1   = x.12^(~skc.14*inv(x.13))
    
    52. ~mc   = ~mc.14
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = x.12^(x.13*inv(~x.10))
        z     = inv(x.12^(x.13*~mc.14*inv(~x.10)))
        z.1   = x.12^(x.13*~skc.14)
    
    53. ~mc   = ~mc.14
        ~ska  = ~ska.14
        ~skc  = ~x.10
        pe    = x.11^(x.12*inv((~x.10*x.13)))
        z     = inv(x.11^(x.12*~mc.14*inv((~x.10*x.13))))
        z.1   = x.11^(x.12*~ska.14*inv(x.13))
    
    54. ~mc   = ~mc.15
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^(x.13*inv((~x.10*~x.11*x.14)))
        z     = inv(x.12^(x.13*~mc.15*inv((~x.10*~x.11*x.14))))
        z.1   = x.12^(x.13*inv(x.14))
    
    55. ~mc   = ~mc.15
        ~ska  = ~x.10
        ~skc  = ~skc.15
        pe    = x.12^(x.13*inv((~x.10*x.14)))
        z     = inv(x.12^(x.13*~mc.15*inv((~x.10*x.14))))
        z.1   = x.12^(x.13*~skc.15*inv(x.14))
    
    56. pe    = DH_neutral
        z     = inv(DH_neutral)
        z.1   = DH_neutral
  */

rule (modulo E) ClientDeriveSS:
   [
   ClientProduceKey( $AP, $Client, psk, pe, ~skc, inv(pe^~ma),
                     add(~ma, ~ska)
   )
   ]
  -->
   [ ClientGetKey( $AP, $Client, psk, ~skc, pe^~skc^~ska ) ]

  /*
  rule (modulo AC) ClientDeriveSS:
     [ ClientProduceKey( $AP, $Client, psk, pe, ~skc, z, add(~ma, ~ska) ) ]
    -->
     [ ClientGetKey( $AP, $Client, psk, ~skc, z.1 ) ]
    variants (modulo AC)
     1. ~ma   = ~ma.10
        ~ska  = ~ska.10
        ~skc  = ~skc.10
        pe    = pe.10
        z     = inv(pe.10^~ma.10)
        z.1   = pe.10^(~ska.10*~skc.10)
    
     2. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.11
        pe    = one^inv(~x.10)
        z     = one
        z.1   = one^~skc.11
    
     3. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^inv((~x.10*~x.11))
        z     = inv(x.12^inv(~x.11))
        z.1   = x.12
    
     4. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^inv((~x.10*~x.11*x.13))
        z     = inv(x.12^inv((~x.11*x.13)))
        z.1   = x.12^inv(x.13)
    
     5. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^(x.13*inv((~x.10*~x.11)))
        z     = inv(x.12^(x.13*inv(~x.11)))
        z.1   = x.12^x.13
    
     6. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^(x.13*inv((~x.10*~x.11*x.14)))
        z     = inv(x.12^(x.13*inv((~x.11*x.14))))
        z.1   = x.12^(x.13*inv(x.14))
    
     7. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.13
        pe    = x.12^inv(~x.10)
        z     = inv(x.12)
        z.1   = x.12^~skc.13
    
     8. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.13
        pe    = inv(x.12)^inv(~x.10)
        z     = x.12
        z.1   = inv(x.12)^~skc.13
    
     9. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = x.12^inv((~x.10*x.13))
        z     = inv(x.12^inv(x.13))
        z.1   = x.12^(~skc.14*inv(x.13))
    
    10. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = x.12^(x.13*inv(~x.10))
        z     = inv(x.12^x.13)
        z.1   = x.12^(x.13*~skc.14)
    
    11. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = (x.12*inv(x.13))^inv(~x.10)
        z     = (x.13*inv(x.12))
        z.1   = (x.12*inv(x.13))^~skc.14
    
    12. ~ma   = ~x.10
        ~ska  = ~x.10
        ~skc  = ~skc.15
        pe    = x.12^(x.13*inv((~x.10*x.14)))
        z     = inv(x.12^(x.13*inv(x.14)))
        z.1   = x.12^(x.13*~skc.15*inv(x.14))
    
    13. ~ma   = ~x.10
        ~ska  = ~ska.11
        ~skc  = ~x.10
        pe    = one^inv(~x.10)
        z     = one
        z.1   = one^~ska.11
    
    14. ~ma   = ~x.10
        ~ska  = ~ska.11
        ~skc  = ~skc.11
        pe    = one^inv(~x.10)
        z     = one
        z.1   = one^(~ska.11*~skc.11*inv(~x.10))
    
    15. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.10
        pe    = x.12^inv((~x.10*~x.11))
        z     = inv(x.12^inv(~x.11))
        z.1   = x.12
    
    16. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.10
        pe    = x.12^inv((~x.10*~x.11*x.13))
        z     = inv(x.12^inv((~x.11*x.13)))
        z.1   = x.12^inv(x.13)
    
    17. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.10
        pe    = x.12^(x.13*inv((~x.10*~x.11)))
        z     = inv(x.12^(x.13*inv(~x.11)))
        z.1   = x.12^x.13
    
    18. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.10
        pe    = x.12^(x.13*inv((~x.10*~x.11*x.14)))
        z     = inv(x.12^(x.13*inv((~x.11*x.14))))
        z.1   = x.12^(x.13*inv(x.14))
    
    19. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.12
        pe    = x.13^inv((~x.10*~x.11*~x.12))
        z     = inv(x.13^inv((~x.11*~x.12)))
        z.1   = x.13^inv(~x.10)
    
    20. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.12
        pe    = x.13^inv((~x.10*~x.11*~x.12*x.14))
        z     = inv(x.13^inv((~x.11*~x.12*x.14)))
        z.1   = x.13^inv((~x.10*x.14))
    
    21. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.12
        pe    = x.13^(x.14*inv((~x.10*~x.11*~x.12)))
        z     = inv(x.13^(x.14*inv((~x.11*~x.12))))
        z.1   = x.13^(x.14*inv(~x.10))
    
    22. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~x.12
        pe    = x.13^(x.14*inv((~x.10*~x.11*~x.12*x.15)))
        z     = inv(x.13^(x.14*inv((~x.11*~x.12*x.15))))
        z.1   = x.13^(x.14*inv((~x.10*x.15)))
    
    23. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~skc.14
        pe    = x.13^inv((~x.10*~x.11))
        z     = inv(x.13^inv(~x.11))
        z.1   = x.13^(~skc.14*inv(~x.10))
    
    24. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~skc.15
        pe    = x.13^inv((~x.10*~x.11*x.14))
        z     = inv(x.13^inv((~x.11*x.14)))
        z.1   = x.13^(~skc.15*inv((~x.10*x.14)))
    
    25. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~skc.15
        pe    = x.13^(x.14*inv((~x.10*~x.11)))
        z     = inv(x.13^(x.14*inv(~x.11)))
        z.1   = x.13^(x.14*~skc.15*inv(~x.10))
    
    26. ~ma   = ~x.10
        ~ska  = ~x.11
        ~skc  = ~skc.16
        pe    = x.13^(x.14*inv((~x.10*~x.11*x.15)))
        z     = inv(x.13^(x.14*inv((~x.11*x.15))))
        z.1   = x.13^(x.14*~skc.16*inv((~x.10*x.15)))
    
    27. ~ma   = ~x.10
        ~ska  = ~ska.13
        ~skc  = ~x.10
        pe    = x.12^inv(~x.10)
        z     = inv(x.12)
        z.1   = x.12^~ska.13
    
    28. ~ma   = ~x.10
        ~ska  = ~ska.13
        ~skc  = ~x.10
        pe    = inv(x.12)^inv(~x.10)
        z     = x.12
        z.1   = inv(x.12)^~ska.13
    
    29. ~ma   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~x.10
        pe    = x.12^inv((~x.10*x.13))
        z     = inv(x.12^inv(x.13))
        z.1   = x.12^(~ska.14*inv(x.13))
    
    30. ~ma   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~x.10
        pe    = x.12^(x.13*inv(~x.10))
        z     = inv(x.12^x.13)
        z.1   = x.12^(x.13*~ska.14)
    
    31. ~ma   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~x.10
        pe    = (x.12*inv(x.13))^inv(~x.10)
        z     = (x.13*inv(x.12))
        z.1   = (x.12*inv(x.13))^~ska.14
    
    32. ~ma   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~x.12
        pe    = x.13^inv((~x.10*~x.12))
        z     = inv(x.13^inv(~x.12))
        z.1   = x.13^(~ska.14*inv(~x.10))
    
    33. ~ma   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~skc.14
        pe    = x.13^inv(~x.10)
        z     = inv(x.13)
        z.1   = x.13^(~ska.14*~skc.14*inv(~x.10))
    
    34. ~ma   = ~x.10
        ~ska  = ~ska.14
        ~skc  = ~skc.14
        pe    = inv(x.13)^inv(~x.10)
        z     = x.13
        z.1   = inv(x.13)^(~ska.14*~skc.14*inv(~x.10))
    
    35. ~ma   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~x.10
        pe    = x.12^(x.13*inv((~x.10*x.14)))
        z     = inv(x.12^(x.13*inv(x.14)))
        z.1   = x.12^(x.13*~ska.15*inv(x.14))
    
    36. ~ma   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~x.12
        pe    = x.13^inv((~x.10*~x.12*x.14))
        z     = inv(x.13^inv((~x.12*x.14)))
        z.1   = x.13^(~ska.15*inv((~x.10*x.14)))
    
    37. ~ma   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~x.12
        pe    = x.13^(x.14*inv((~x.10*~x.12)))
        z     = inv(x.13^(x.14*inv(~x.12)))
        z.1   = x.13^(x.14*~ska.15*inv(~x.10))
    
    38. ~ma   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~skc.15
        pe    = x.13^inv((~x.10*x.14))
        z     = inv(x.13^inv(x.14))
        z.1   = x.13^(~ska.15*~skc.15*inv((~x.10*x.14)))
    
    39. ~ma   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~skc.15
        pe    = x.13^(x.14*inv(~x.10))
        z     = inv(x.13^x.14)
        z.1   = x.13^(x.14*~ska.15*~skc.15*inv(~x.10))
    
    40. ~ma   = ~x.10
        ~ska  = ~ska.15
        ~skc  = ~skc.15
        pe    = (x.13*inv(x.14))^inv(~x.10)
        z     = (x.14*inv(x.13))
        z.1   = (x.13*inv(x.14))^(~ska.15*~skc.15*inv(~x.10))
    
    41. ~ma   = ~x.10
        ~ska  = ~ska.16
        ~skc  = ~x.12
        pe    = x.13^(x.14*inv((~x.10*~x.12*x.15)))
        z     = inv(x.13^(x.14*inv((~x.12*x.15))))
        z.1   = x.13^(x.14*~ska.16*inv((~x.10*x.15)))
    
    42. ~ma   = ~x.10
        ~ska  = ~ska.16
        ~skc  = ~skc.16
        pe    = x.13^(x.14*inv((~x.10*x.15)))
        z     = inv(x.13^(x.14*inv(x.15)))
        z.1   = x.13^(x.14*~ska.16*~skc.16*inv((~x.10*x.15)))
    
    43. ~ma   = ~ma.12
        ~ska  = ~ska.12
        ~skc  = ~x.10
        pe    = x.11^inv(~x.10)
        z     = inv(x.11^(~ma.12*inv(~x.10)))
        z.1   = x.11^~ska.12
    
    44. ~ma   = ~ma.12
        ~ska  = ~ska.12
        ~skc  = ~skc.12
        pe    = x.10^x.11
        z     = inv(x.10^(x.11*~ma.12))
        z.1   = x.10^(x.11*~ska.12*~skc.12)
    
    45. ~ma   = ~ma.13
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^inv((~x.10*~x.11))
        z     = inv(x.12^(~ma.13*inv((~x.10*~x.11))))
        z.1   = x.12
    
    46. ~ma   = ~ma.13
        ~ska  = ~x.10
        ~skc  = ~skc.13
        pe    = x.12^inv(~x.10)
        z     = inv(x.12^(~ma.13*inv(~x.10)))
        z.1   = x.12^~skc.13
    
    47. ~ma   = ~ma.13
        ~ska  = ~ska.13
        ~skc  = ~x.10
        pe    = x.11^inv((~x.10*x.12))
        z     = inv(x.11^(~ma.13*inv((~x.10*x.12))))
        z.1   = x.11^(~ska.13*inv(x.12))
    
    48. ~ma   = ~ma.13
        ~ska  = ~ska.13
        ~skc  = ~x.10
        pe    = x.11^(x.12*inv(~x.10))
        z     = inv(x.11^(x.12*~ma.13*inv(~x.10)))
        z.1   = x.11^(x.12*~ska.13)
    
    49. ~ma   = ~ma.14
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^inv((~x.10*~x.11*x.13))
        z     = inv(x.12^(~ma.14*inv((~x.10*~x.11*x.13))))
        z.1   = x.12^inv(x.13)
    
    50. ~ma   = ~ma.14
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^(x.13*inv((~x.10*~x.11)))
        z     = inv(x.12^(x.13*~ma.14*inv((~x.10*~x.11))))
        z.1   = x.12^x.13
    
    51. ~ma   = ~ma.14
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = x.12^inv((~x.10*x.13))
        z     = inv(x.12^(~ma.14*inv((~x.10*x.13))))
        z.1   = x.12^(~skc.14*inv(x.13))
    
    52. ~ma   = ~ma.14
        ~ska  = ~x.10
        ~skc  = ~skc.14
        pe    = x.12^(x.13*inv(~x.10))
        z     = inv(x.12^(x.13*~ma.14*inv(~x.10)))
        z.1   = x.12^(x.13*~skc.14)
    
    53. ~ma   = ~ma.14
        ~ska  = ~ska.14
        ~skc  = ~x.10
        pe    = x.11^(x.12*inv((~x.10*x.13)))
        z     = inv(x.11^(x.12*~ma.14*inv((~x.10*x.13))))
        z.1   = x.11^(x.12*~ska.14*inv(x.13))
    
    54. ~ma   = ~ma.15
        ~ska  = ~x.10
        ~skc  = ~x.11
        pe    = x.12^(x.13*inv((~x.10*~x.11*x.14)))
        z     = inv(x.12^(x.13*~ma.15*inv((~x.10*~x.11*x.14))))
        z.1   = x.12^(x.13*inv(x.14))
    
    55. ~ma   = ~ma.15
        ~ska  = ~x.10
        ~skc  = ~skc.15
        pe    = x.12^(x.13*inv((~x.10*x.14)))
        z     = inv(x.12^(x.13*~ma.15*inv((~x.10*x.14))))
        z.1   = x.12^(x.13*~skc.15*inv(x.14))
    
    56. pe    = DH_neutral
        z     = inv(DH_neutral)
        z.1   = DH_neutral
  */

rule (modulo E) ClientSendCommit:
   [
   ClientReadyCommit( $AP, $Client, psk, pe, ~skc, elta, eltc, scalara,
                      scalarc
   ),
   ClientGetKey( $AP, $Client, psk, ~skc, ss )
   ]
  --[
  LblClientSendCommit( $AP, $Client, psk, ss,
                       hkck(ss, 'DragonflyKeyDerivation', '0'),
                       hmk(ss, 'DragonflyKeyDerivation', '1')
  )
  ]->
   [
   ClientStep2( $AP, $Client, psk, ~skc, elta, eltc, scalara, scalarc, ss,
                hkck(ss, 'DragonflyKeyDerivation', '0'),
                hmk(ss, 'DragonflyKeyDerivation', '1')
   ),
   Out( h(<hkck(ss, 'DragonflyKeyDerivation', '0'), scalarc, scalara, eltc, 
           elta, $Client>)
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) APSendCommit:
   [
   APGetKey( $AP, $Client, psk, ~ska, ss ),
   APStep1( $AP, $Client, psk, pe, ~ska, elta, eltc, scalara, scalarc ),
   In( clientcommit )
   ]
  --[
  Eq( clientcommit,
      h(<hkck(ss, 'DragonflyKeyDerivation', '0'), scalarc, scalara, eltc, 
         elta, $Client>)
  ),
  LblAPSentCommit( $AP, $Client, ss,
                   hkck(ss, 'DragonflyKeyDerivation', '0'),
                   hmk(ss, 'DragonflyKeyDerivation', '1')
  )
  ]->
   [
   Out( h(<hkck(ss, 'DragonflyKeyDerivation', '0'), scalara, scalarc, elta, 
           eltc, $AP>)
   ),
   APSentCommit( $AP, $Client, psk, ~ska, elta, eltc, scalara, scalarc, ss,
                 hkck(ss, 'DragonflyKeyDerivation', '0'),
                 hmk(ss, 'DragonflyKeyDerivation', '1')
   ),
   FourWayAPReady( $AP, $Client, hmk(ss, 'DragonflyKeyDerivation', '1') )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ClientRecvCommit:
   [
   ClientStep2( $AP, $Client, psk, ~skc, elta, eltc, scalara, scalarc, ss,
                kck, mk
   ),
   In( apcommit )
   ]
  --[
  Eq( apcommit, h(<kck, scalara, scalarc, elta, eltc, $AP>) ),
  LblClientRecvCommit( $AP, $Client, ss, kck, mk )
  ]->
   [
   ClientRecvCommit( $AP, $Commit, psk, ~skc, elta, eltc, scalara, scalarc,
                     ss, kck, mk
   ),
   FourWayClientReady( $AP, $Client, mk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) FourWayAPCreateSession:
   [ FourWayAPReady( $AP, $Client, psk ), Random4( ~ANonce ) ]
  -->
   [ APSentRandom( $AP, $Client, psk, ~ANonce ), Out( <'1', ~ANonce> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) FourWayClientCreateSession:
   [
   FourWayClientReady( $AP, $Client, psk ), In( ANonce ), Random5( ~SNonce )
   ]
  --[
  ClientStarted( $AP, $Client, ~SNonce, ANonce ),
  ClientStartedKeys( $AP, $Client,
                     hptk($AP, $Client, ANonce, ~SNonce, 'Pairwisekeyexpansion', hpsk(psk))
  )
  ]->
   [
   ClientSentRandom( $AP, $Client, ~SNonce, ANonce,
                     hptk($AP, $Client, ANonce, ~SNonce, 'Pairwisekeyexpansion', hpsk(psk))
   ),
   Out( <<'2', ~SNonce>, 
         mac(<'2', ~SNonce>,
             hptk($AP, $Client, ANonce, ~SNonce, 'Pairwisekeyexpansion', hpsk(psk)))
        >
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) APRecvMsg2:
   [ In( <<'2', SNonce>, m> ), APSentRandom( $AP, $Client, psk, ~ANonce ) ]
  --[
  Eq( verif(m, <'2', SNonce>,
            hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk))),
      true
  ),
  LblRecvMsg2( ),
  LblAPSentMsg3( $AP, $Client, SNonce, ~ANonce,
                 hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk))
  ),
  APStarted( $AP, $Client, SNonce, ~ANonce ),
  APStartedKeys( $AP, $Client,
                 hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk))
  )
  ]->
   [
   APSentMsg3( $AP, $Client, psk, SNonce, ~ANonce,
               hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk))
   ),
   Out( <<'3', ~ANonce>, 
         mac(<'3', ~ANonce>,
             hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk)))
        >
   )
   ]

  /*
  rule (modulo AC) APRecvMsg2:
     [ In( <<'2', SNonce>, m> ), APSentRandom( $AP, $Client, psk, ~ANonce ) ]
    --[
    Eq( z, true ), LblRecvMsg2( ),
    LblAPSentMsg3( $AP, $Client, SNonce, ~ANonce,
                   hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk))
    ),
    APStarted( $AP, $Client, SNonce, ~ANonce ),
    APStartedKeys( $AP, $Client,
                   hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk))
    )
    ]->
     [
     APSentMsg3( $AP, $Client, psk, SNonce, ~ANonce,
                 hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk))
     ),
     Out( <<'3', ~ANonce>, 
           mac(<'3', ~ANonce>,
               hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion', hpsk(psk)))
          >
     )
     ]
    variants (modulo AC)
    1. $AP   = $AP.17
       $Client
             = $Client.18
       ~ANonce
             = ~ANonce.19
       SNonce
             = SNonce.20
       m     = m.21
       psk   = psk.22
       z     = verif(m.21, <'2', SNonce.20>,
                     hptk($AP.17, $Client.18, ~ANonce.19, SNonce.20, 'Pairwisekeyexpansion',
                          hpsk(psk.22)))
    
    2. $AP   = $AP.17
       $Client
             = $Client.18
       ~ANonce
             = ~ANonce.19
       SNonce
             = SNonce.20
       m     = mac(<'2', SNonce.20>,
                   hptk($AP.17, $Client.18, ~ANonce.19, SNonce.20, 'Pairwisekeyexpansion',
                        hpsk(psk.22)))
       psk   = psk.22
       z     = true
  */

rule (modulo E) ClientRecvMsg3:
   [
   ClientSentRandom( $AP, $Client, ~SNonce, ANonce, ptk ),
   In( <<'3', ANonce>, m> )
   ]
  --[
  Eq( verif(m, <'3', ANonce>, ptk), true ),
  LblClientSentMsg4( $AP, $Client, ~SNonce, ANonce, ptk ), LblRecvMsg3( ),
  ClientEnded( $AP, $Client, ~SNonce, ANonce ),
  ClientEndedKeys( $AP, $Client, ptk )
  ]->
   [
   ClientSentMsg4( $AP, $Client, ~SNonce, ANonce, ptk ),
   Out( <<'4', 'End'>, mac(<'4', 'End'>, ptk)> )
   ]

  /*
  rule (modulo AC) ClientRecvMsg3:
     [
     ClientSentRandom( $AP, $Client, ~SNonce, ANonce, ptk ),
     In( <<'3', ANonce>, m> )
     ]
    --[
    Eq( z, true ), LblClientSentMsg4( $AP, $Client, ~SNonce, ANonce, ptk ),
    LblRecvMsg3( ), ClientEnded( $AP, $Client, ~SNonce, ANonce ),
    ClientEndedKeys( $AP, $Client, ptk )
    ]->
     [
     ClientSentMsg4( $AP, $Client, ~SNonce, ANonce, ptk ),
     Out( <<'4', 'End'>, mac(<'4', 'End'>, ptk)> )
     ]
    variants (modulo AC)
    1. ANonce
             = ANonce.14
       m     = m.15
       ptk   = ptk.16
       z     = verif(m.15, <'3', ANonce.14>, ptk.16)
    
    2. ANonce
             = ANonce.14
       m     = mac(<'3', ANonce.14>, ptk.16)
       ptk   = ptk.16
       z     = true
  */

rule (modulo E) APRecvMsg4:
   [
   APSentMsg3( $AP, $Client, psk, SNonce, ~ANonce, ptk ),
   In( <<'4', 'End'>, m> )
   ]
  --[
  Eq( verif(m, <'4', 'End'>, ptk), true ),
  LblAPRecvMsg4( $AP, $Client, SNonce, ~ANonce, ptk ), LblRecvMsg4( ),
  APEnded( $AP, $Client, SNonce, ~ANonce ),
  APEndedKeys( $AP, $Client, ptk )
  ]->
   [ APRecvMsg4( $AP, $Client, psk, SNonce, ~ANonce, ptk ) ]

  /*
  rule (modulo AC) APRecvMsg4:
     [
     APSentMsg3( $AP, $Client, psk, SNonce, ~ANonce, ptk ),
     In( <<'4', 'End'>, m> )
     ]
    --[
    Eq( z, true ), LblAPRecvMsg4( $AP, $Client, SNonce, ~ANonce, ptk ),
    LblRecvMsg4( ), APEnded( $AP, $Client, SNonce, ~ANonce ),
    APEndedKeys( $AP, $Client, ptk )
    ]->
     [ APRecvMsg4( $AP, $Client, psk, SNonce, ~ANonce, ptk ) ]
    variants (modulo AC)
    1. m     = m.14
       ptk   = ptk.16
       z     = verif(m.14, <'4', 'End'>, ptk.16)
    
    2. m     = mac(<'4', 'End'>, ptk.12)
       ptk   = ptk.12
       z     = true
  */

restriction RestrMisgeneratesOnlyOnce:
  "∀ #i #j.
    ((MisgenerateOnlyOnce( ) @ #i) ∧ (MisgenerateOnlyOnce( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction RstrEq:
  "∀ a b #i. (Eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

lemma key_freshness_client:
  all-traces
  "∀ ap client ptk #i.
    (ClientEndedKeys( ap, client, ptk ) @ #i) ⇒
    ((¬(∃ ap2 client2 #j.
         (ClientEndedKeys( ap2, client2, ptk ) @ #j) ∧ (¬(#i = #j)))) ∨
     (∃ #r. RevLtk( ) @ #r))"
/*
guarded formula characterizing all counter-examples:
"∃ ap client ptk #i.
  (ClientEndedKeys( ap, client, ptk ) @ #i)
 ∧
  (∃ ap2 client2 #j.
    (ClientEndedKeys( ap2, client2, ptk ) @ #j) ∧ ¬(#i = #j)) ∧
  (∀ #r. (RevLtk( ) @ #r) ⇒ ⊥)"
*/
simplify
solve( (#i < #j)  ∥ (#j < #i) )
  case case_1
  solve( ClientSentRandom( $AP, $Client, ~SNonce, ANonce, ptk ) ▶₀ #i )
    case FourWayClientCreateSession_case_1
    solve( ClientSentRandom( $AP.1, $Client.1, ~SNonce.1, ANonce.1,
                             hptk($AP, $Client, ANonce, ~SNonce, 'Pairwisekeyexpansion',
                                  hpsk(hmk(hpe($AP, $Client, staticpsk)^(~ska*~skc),
                                           'DragonflyKeyDerivation', '1')))
           ) ▶₀ #j )
      case FourWayClientCreateSession_case_1
      by contradiction /* cyclic */
    next
      case FourWayClientCreateSession_case_2
      by contradiction /* cyclic */
    qed
  next
    case FourWayClientCreateSession_case_2
    solve( ClientSentRandom( $AP.1, $Client.1, ~SNonce.1, ANonce.1,
                             hptk($AP, $Client, ANonce, ~SNonce, 'Pairwisekeyexpansion',
                                  hpsk(hmk(hpe($AP, $Client, staticpsk)^(~ska*~skc),
                                           'DragonflyKeyDerivation', '1')))
           ) ▶₀ #j )
      case FourWayClientCreateSession_case_1
      by contradiction /* cyclic */
    next
      case FourWayClientCreateSession_case_2
      by contradiction /* cyclic */
    qed
  qed
next
  case case_2
  solve( ClientSentRandom( $AP, $Client, ~SNonce, ANonce, ptk ) ▶₀ #i )
    case FourWayClientCreateSession_case_1
    solve( ClientSentRandom( $AP.1, $Client.1, ~SNonce.1, ANonce.1,
                             hptk($AP, $Client, ANonce, ~SNonce, 'Pairwisekeyexpansion',
                                  hpsk(hmk(hpe($AP, $Client, staticpsk)^(~ska*~skc),
                                           'DragonflyKeyDerivation', '1')))
           ) ▶₀ #j )
      case FourWayClientCreateSession_case_1
      by contradiction /* cyclic */
    next
      case FourWayClientCreateSession_case_2
      by contradiction /* cyclic */
    qed
  next
    case FourWayClientCreateSession_case_2
    solve( ClientSentRandom( $AP.1, $Client.1, ~SNonce.1, ANonce.1,
                             hptk($AP, $Client, ANonce, ~SNonce, 'Pairwisekeyexpansion',
                                  hpsk(hmk(hpe($AP, $Client, staticpsk)^(~ska*~skc),
                                           'DragonflyKeyDerivation', '1')))
           ) ▶₀ #j )
      case FourWayClientCreateSession_case_1
      by contradiction /* cyclic */
    next
      case FourWayClientCreateSession_case_2
      by contradiction /* cyclic */
    qed
  qed
qed

lemma key_freshness_ap:
  all-traces
  "∀ ap client ptk #i.
    (APEndedKeys( ap, client, ptk ) @ #i) ⇒
    ((¬(∃ ap2 client2 #j.
         (APEndedKeys( ap2, client2, ptk ) @ #j) ∧ (¬(#i = #j)))) ∨
     (∃ #r. RevLtk( ) @ #r))"
/*
guarded formula characterizing all counter-examples:
"∃ ap client ptk #i.
  (APEndedKeys( ap, client, ptk ) @ #i)
 ∧
  (∃ ap2 client2 #j.
    (APEndedKeys( ap2, client2, ptk ) @ #j) ∧ ¬(#i = #j)) ∧
  (∀ #r. (RevLtk( ) @ #r) ⇒ ⊥)"
*/
simplify
solve( (#i < #j)  ∥ (#j < #i) )
  case case_1
  solve( APSentMsg3( $AP, $Client, psk, SNonce, ~ANonce, ptk ) ▶₀ #i )
    case APRecvMsg2_case_1
    solve( APSentMsg3( $AP.1, $Client.1, psk, SNonce.1, ~ANonce.1,
                       hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion',
                            hpsk(hmk(hpe($AP, $Client, staticpsk)^(~ska*~skc),
                                     'DragonflyKeyDerivation', '1')))
           ) ▶₀ #j )
      case APRecvMsg2_case_1
      by contradiction /* cyclic */
    next
      case APRecvMsg2_case_2
      by contradiction /* cyclic */
    qed
  next
    case APRecvMsg2_case_2
    solve( APSentMsg3( $AP.1, $Client.1, psk, SNonce.1, ~ANonce.1,
                       hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion',
                            hpsk(hmk(hpe($AP, $Client, staticpsk)^(~ska*~skc),
                                     'DragonflyKeyDerivation', '1')))
           ) ▶₀ #j )
      case APRecvMsg2_case_1
      by contradiction /* cyclic */
    next
      case APRecvMsg2_case_2
      by contradiction /* cyclic */
    qed
  qed
next
  case case_2
  solve( APSentMsg3( $AP, $Client, psk, SNonce, ~ANonce, ptk ) ▶₀ #i )
    case APRecvMsg2_case_1
    solve( APSentMsg3( $AP.1, $Client.1, psk, SNonce.1, ~ANonce.1,
                       hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion',
                            hpsk(hmk(hpe($AP, $Client, staticpsk)^(~ska*~skc),
                                     'DragonflyKeyDerivation', '1')))
           ) ▶₀ #j )
      case APRecvMsg2_case_1
      by contradiction /* cyclic */
    next
      case APRecvMsg2_case_2
      by contradiction /* cyclic */
    qed
  next
    case APRecvMsg2_case_2
    solve( APSentMsg3( $AP.1, $Client.1, psk, SNonce.1, ~ANonce.1,
                       hptk($AP, $Client, ~ANonce, SNonce, 'Pairwisekeyexpansion',
                            hpsk(hmk(hpe($AP, $Client, staticpsk)^(~ska*~skc),
                                     'DragonflyKeyDerivation', '1')))
           ) ▶₀ #j )
      case APRecvMsg2_case_1
      by contradiction /* cyclic */
    next
      case APRecvMsg2_case_2
      by contradiction /* cyclic */
    qed
  qed
qed

































/*
WARNING: the following wellformedness checks failed!

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule AttDerivePubKey: 
Failed to derive Variable(s): ~m, ~s

Rule APDeriveSS: 
Failed to derive Variable(s): ~mc, ~skc

Rule ClientDeriveSS: 
Failed to derive Variable(s): ~ma, ~ska
*/

/*
Generated from:
Tamarin version 1.10.0
Maude version 3.3
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2025-01-20 17:15:39.562956625 UTC
*/

end

==============================================================================
summary of summaries:

analyzed: wpa3_reuse_once_3_5.spthy

  processing time: 10.22s
  
  WARNING: 1 wellformedness check failed!
           The analysis results might be wrong!
  
  key_freshness_client (all-traces): verified (16 steps)
  key_freshness_ap (all-traces): verified (16 steps)

==============================================================================
